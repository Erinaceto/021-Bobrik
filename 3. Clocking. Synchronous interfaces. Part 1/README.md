# 3. Тактирование. SPI. I2C

## Поставленная задача
Включить на МК STM32 два интерфейса SPI и передать данные с одного на другой. Подтверждением может быть скриншот отладчика.

# Обмен между 2 модулями SPI на одном МК

1. Задача кнешна довольно странная, и вроде выглядит простой, однако самое интересное впереди. Чтож, схему подключения и настройки можно показать прямо в самом кубике и описать тут. Используются модули SPI_1 и SPI_2. На обоих включим аппаратный чип селект

![Конфигурация выводов](./Images/Pins%20configuration.png)

SPI 1 - мастер передатчик

![Конфигурация SPI 1](./Images/SPI_1%20configuration.png)

SPI 2 - слейв приёмник

![Конфигурация SPI 2](./Images/SPI_2%20configuration.png)

В модуле NVIC приоритет SPI 2 выше чем SPI 1 (ну так логичнее, по идее)

![Конфигурация SPI NVIC](./Images/SPI%20NVIC%20configuration.png)

2. Далее просто генерируем код, причём ставим галочку, чтобы генерация кода для переферии шла по отдельным файлам. В самом начале напишем в файлах spi.h и spi.c функции обёрки, чтобы не вытаскивать наружу структуры hspi1 и hspi2(хотя функции для их получения так же можно сделать, для тестов).

![Функции обёртки](./Images/Wrapper%20functions.png)

3. Теперь настало время тестов и шизотеорий. В данной конфигурации передача и приём в прерывании не получается. Передача только в блокирующем режиме. Но приём в режиме прерывания возможен. Как побайтово в цикле, так и сразу нужный кусок. Почему? Точно сказать не могу. Но есть предположение что это происходит из за атамарности стекинга. 
Приём и передача происходят в одновременно. Для разных МК это не проблема, но, когда это 1 МК, то во время стекинга одного из прерываний, второе теряется. Потому передача или приём следующего байта становится не возможной. 

![Код основной программы](./Images/Variants%20of%20transfer.png)

4. Результат: Задача выполнена

![Результат передачи](./Images/Transfer%20complete.png)